---
title: (c语言)数据结构与算法 - 顺序表与链表
date: 2017-07-27 14:11:00
categories:
- c
- 数据结构与算法
tags:
- c
- 数据结构与算法
keywords: c语言 数据结构与算法 顺序表 链表 比较
---

> 
`顺序存储`表示是将数据元素存放于一个连续的存储空间中，实现顺序存取或(按下标)直接存取，它的`存储效率高，存取速度快`；但它的空间大小一经定义，在程序整个运行期间不会发生改变，因此，`不易扩充`，同时，由于在插入或删除时，为保持原有次序(没有规定元素进栈顺序)，平均需要移动一半(或近一半)元素，`修改效率不高`
`链接存储`表示的存储空间一般在程序的运行过程中动态分配和释放，且只要存储器中还有空间，就不会产生存储溢出的问题，同时在插入和删除时不需要保持数据元素原来的物理顺序，只需要保持原来的逻辑顺序，因此不必移动数据，只需修改它们的链接指针，`修改效率较高`，但存取表中的数据元素时，只能循链顺序访问，因此`存取效率不高`

<!-- more -->

## 顺序表
**`一维数组`**
一维数组在内存中占用的存储空间就是一组连续的存储区域，因此，用一维数组来表示顺序表的数据存储区域是再合适不过的；

从结构上考虑，通常将`存储区域data`和`表长len`封装为一个结构，作为顺序表的类型：
<pre><code class="language-c line-numbers"><script type="text/plain">typedef struct{
    datatype data[MAXSIZE];
    int len;
} SeqList;
</script></code></pre>

- `SeqList *L`：定义一个顺序表的指针L
- `L = (SeqList *)malloc(sizeof(SeqList))`：申请内存空间
- `L->data`：data区域
- `L->len`：元素个数，即长度
- `L->data[0] ~ L->data[L->len-1]`：元素存放区域

## 链表
**`单链表`**
单向链表(单链表)是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始
单向链表的数据结构可以分为两部分：数据域和指针域，数据域存储数据，指针域指向下一个储存节点的地址
<pre><code class="language-c line-numbers"><script type="text/plain">typedef struct LNode{
    datatype data;
    struct LNode *next;
} LNode, *LinkList;
</script></code></pre>

其中：`LNode`是结点的类型，`LinkList`是链表的头指针的类型

对于单链表而言，最后一个结点的指针域是空指针，并且链表中没有指向第一个结点的指针

**`循环单链表`**
循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环

在循环单链表中，表尾结点的next域指向L，故表中没有指针域为NULL的结点，因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针

循环单链表的插入、删除算法与单链表的几乎一样，所不同的是如果操作是在表尾进行，则执行的操作不相同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个 “环”，因此，在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾

在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表，有时对单链表常做的操作是在表头和表尾进行的，此时可对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高

**`双链表`**
双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱
所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点
<pre><code class="language-c line-numbers"><script type="text/plain">typedef struct DuLNode{
    datatype data;
    struct DuLNode *prior, *next;
} DuLNode, *DuLinkList;
</script></code></pre>

**`循环双链表`**
由循环单链表的定义不难推出循环双链表，不同的是在循环双链表中，头结点的prior指针还要指向表尾结点;
在循环双链表L中，某结点*p为尾结点时，p->next=L；当循环双链表为空表时，其头结点的prior域和next域都等于L

**`静态链表`**
静态链表是`借助数组`来描述线性表的链式存储结构，结点也有`数据域data`和`指针域next`;
与前面所讲的链表中的指针不同的是，这里的指针是`结点的相对地址(数组下标)`，又称为游标;
和顺序表一样，静态链表也要`预先分配一块连续的内存空间`

静态链表以`next == -1`作为其结束的标志;
静态链表的插入、删除操作与动态链表相同，只需要修改指针，而不需要移动元素;
总体来说，静态链表没有单链表使用起来方便，但是在一些不支持指针的高级语言(如Basic)中，这又是一种非常巧妙的设计方法
<pre><code class="language-c line-numbers"><script type="text/plain">typedef struct{
    datatype data;
    int next;
} SLinkList[MAXSIZE];
</script></code></pre>

## 顺序表与链表的比较
前面介绍了线性表的逻辑结构及它的两种存储结构：`顺序表`和`链表`

通过对它们的讨论可知它们各有优缺点，`顺序存储`有三个`优点`：
- 方法简单，各种高级语言中都有数组，容易实现
- 不用为表示结点间的逻辑关系而增加额外的存储开销
- 顺序表具有按元素序号随机访问的特点

但它也有两个`缺点`：
- 在顺序表中做插入删除操作时，平均移动大约表中一半的元素，因此对n较大的顺序表效率低
- 需要预先分配足够大的存储空间，估计过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出

`链表`的`优缺点恰好与顺序表相反`；在实际中怎样选取存储结构呢？通常有以下几点考虑：

**基于存储的考虑**
顺序表的存储空间是静态分配的，在程序执行之前必须明确规定它的存储规模，也就是说事先对"MAXSIZE"要有合适的设定，过大造成浪费，过小造成溢出；可见对线性表的长度或存储规模难以估计时，不宜采用顺序表；
链表不用事先估计存储规模，但链表的存储密度较低，存储密度是指一个结点中数据元素所占的存储单元和整个结点所占的存储单元之比，显然链式存储结构的存储密度是小于1的

**基于运算的考虑**
在顺序表中按序号`访问`ai的时间性能时`O(1)`，而链表中按序号`访问`的时间性能`O(n)`;
所以如果经常做的运算是按序号访问数据元素，显然顺序表优于链表；
而在顺序表中做插入、删除时平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的；
在链表中作插入、删除，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者

**基于环境的考虑**
顺序表容易实现，任何高级语言中都有数组类型，链表的操作是基于指针的，相对来讲前者简单些，也是用户考虑的一个因素

总之，两种存储结构各有长短，选择哪一种由实际问题中的主要因素决定
通常“较稳定”的线性表选择顺序存储，而频繁做插入删除的即动态性较强的线性表宜选择链式存储
