---
title: Java 深入理解 JVM 虚拟机
date: 2017-09-23 18:11:00
categories:
- java
tags:
- java
keywords: Java 深入理解 JVM 虚拟机
---

> 
Java 深入理解 JVM 虚拟机，初识 JVM、JVM 内存模型、JVM 类加载机制、Java 对象的访问方式、Java 内存分配机制、GC 机制&算法

<!-- more -->

## 初识 JVM
JVM：**Java Virtual Machine**，意为`Java 虚拟机`。
> 
虚拟机：指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统；

有哪些虚拟机：
1) VMWare、Virtual Box：使用软件模拟物理 CPU 的指令集；
2) JVM：使用软件模拟 Java 字节码的指令集。

我们都知道 Java 是跨平台的，可以实现"一次编译，到处运行"的目的。
但是，跨平台的是 Java 程序，即编译后的字节码是跨平台的，但是 JVM 虚拟机不是，每个平台都有其特定的 JVM；

JVM 和一个普通的可执行文件没有任何区别，在操作系统的层次上讲，并不会对 JVM 有特殊照顾；
JVM 有自己的进程空间，和一般的可执行文件一样，分为`text`代码区、`data`数据区、`bss`初始化为0或未初始化的静态变量存储区、`heap`堆区、`stack`栈区。其中`text`、`data`、`bss`在编译时就能确定，而`heap`、`stack`则是运行时存在的，是动态的。

因此，对于在 shell 中执行命令：`java Main`，表示：
1) 当前 shell 进程进行 fork() 系统调用，创建一个子进程，此时新进程拥有属于自己的 pid；
2) 然后子进程进行 exec() 系统调用，载入可执行文件 java，开始执行新的程序 java，并且传入参数 Main。

这个过程和运行一个普通程序是一样的，没有"区别对待"；

**JVM 发展史**
1) 1996年：SUN JDK 1.0 Classic VM
纯解释运行，使用外挂进行 JIT 即时编译。

2) 1997年：JDK1.1 发布
AWT、内部类、JDBC、RMI、反射。

3) 1998年：JDK1.2 Solaris Exact VM
JIT、解释器混合
Accurate Memory Management 精确内存管理，数据类型敏感
提升了 GC 性能
> 
注：从 JDK1.2 开始，称为 Java 2，于是有了 J2SE J2EE J2ME 的出现，同时加入 Swing Collections。

4) 2000年：JDK 1.3，Hotspot 作为默认虚拟机发布
加入 JavaSound

5) 2002年：JDK 1.4【Java真正走向成熟的一个版本】，Classic VM 退出历史舞台
Assert断言、regex正则表达式、NIO非阻塞IO、IPV6支持、日志API、加密类库

6) 2004年：JDK 1.5【至关重要的版本】，即 JDK5 、J2SE 5 、Java 5
泛型、注解、枚举、自动装箱、可变长参数、Foreach循环等

7) 2006年：JDK 1.6 发布，JDK 6
脚本语言支持、JDBC 4.0、Java编译器 API

8) 2011年：JDK7 发布
延误项目推出到JDK8、G1（全新的 GC 收集器）、动态语言增强、64位系统中的压缩指针、NIO 2.0

9) 2014年：JDK8 发布【重要的版本】
Lambda表达式、语法增强、Java类型注解

10) 2016年：计划发布 JDK9
模块化

**重大历史事件**
1) 使用最为广泛的 JVM 为 HotSpot:：HotSpot 为 Longview Technologies 开发，被 SUN 收购；
2) 2006年：Java 开源，并建立 OpenJDK、HotSpot 成为 Sun JDK 和 OpenJDK 中所带的默认虚拟机；
3) 2008年：Oracle 收购 BEA，得到 JRockit VM；
4) 2009年4月20日：Oracle 公司正式宣布以 74 亿美金的价格收购 Sun 公司；得到 Hotspot；
5) Oracle 宣布在 JDK8 时整合 JRockit 和 Hotspot，将这两款优秀的虚拟机取长补短，最终合二为一；

**Java语言规范**
Java 语言规范主要体现在以下几点：
1) 语法
2) 变量
3) 类型
4) 文法

**JVM 规范**
JVM 主要定义二进制 class 文件和 JVM 指令集等；

JVM 语言规范主要体现在以下几点：
1) Class 文件类型
2) 运行时数据
3) 帧栈
4) 虚拟机的启动
5) 虚拟机的指令集

此外，JVM 需要对 Java Library 提供以下支持：（因为这些东西没有办法通过 Java 语言本身来实现）
1) 反射 java.lang.reflect
2) ClassLoader 类加载器
3) 初始化 class 和 interface
4) 安全相关 java.security
5) 多线程
6) 弱引用

**JVM server/client 模式区别**
<pre><code class="language-java line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [14:19:23]
$ java -version
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)
</script></code></pre>



注意第三行的输出，Server VM，表示当前 JVM 的默认模式是 Server 模式。
1) `Client模式`：启动速度快，运行速度慢；
2) `Server模式`：启动速度慢，运行速度快。

对于 32 位平台，可以通过配置`$JAVA_HOME/jre/lib/i386/jvm.cfg`文件切换默认模式；
对于 64 位平台，只能使用 Server 模式，Client 模式已经不存在了，不能切换为 Client 模式。

而现在大多数服务器都是 64 位的，因此基本可以不用管什么 Client/Server 模式。

## JVM 内存模型
![JVM 内存模型](/images/java-memory.png)
![JVM 内存模型](/images/java-memory-2.jpg)

Java 内存模型，往往是指 Java 程序在运行时内存的模型，而 Java 代码是运行在 Java 虚拟机之上的，由 Java 虚拟机通过解释执行(解释器)或编译执行(即时编译器)来完成，故 Java 内存模型，也就是指 Java 虚拟机的运行时内存模型。

作为 Java 开发人员来说，并不需要像 C/C++ 开发人员，需要时刻注意内存的释放，而是全权交给虚拟机去管理，那么有就必要了解虚拟机的运行时内存是如何构成的。

运行时内存模型，分为**线程私有**和**共享数据区**两大类：
1) 线程私有的数据区包含`程序计数器`、`虚拟机栈`、`本地方法栈`；
2) 所有线程共享的数据区包含`堆`、`方法区`，在方法区内有一个`常量池`。

（1）**线程私有区**：
1) `程序计数器`，记录正在执行的虚拟机`字节码的地址`；
2) `虚拟机栈`：方法执行的内存区，每个方法执行时会在虚拟机栈中创建`栈帧`；
3) `本地方法栈`：虚拟机的`Native`方法执行的内存区；

（2）**线程共享区**：
1) `Java堆`：`对象`分配内存的主要区域；
2) `方法区`：存放`类信息`、`常量`、`静态变量`、编译器编译后的`代码`等数据；
3) `常量池`：存放编译器生成的各种`字面量`和`符号引用`，是方法区的一部分。

**详细模型**
`运行时内存`分为**五大块区域**，前面简要介绍了每个区域的功能，那接下来再详细说明每个区域的内容，Java 内存总体结构图如下：
![Java 内存详细模型](/images/java-memory-3.png)

**程序计数器 PC**
`程序计数器`，当前线程所执行的字节码行号指示器。每个线程都有自己计数器，是私有内存空间，该区域是整个内存中较小的一块。
当线程正在执行一个 Java 方法时，PC 计数器记录的是**正在执行**的虚拟机字节码的地址；当线程正在执行的一个 Native 方法时，PC 计数器则为`空（Undefined）`；
> 此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。

**虚拟机栈 VM Stack**
`虚拟机栈`，生命周期与线程相同，是 Java 方法执行的内存模型。每个 Java 方法执行的同时都会创建一个`栈帧结构`，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。

栈可以是动态分配也可以固定大小。如果线程请求一个超过允许范围的空间，就会抛出一个`StackOverflowError`。如果线程需要一个新的栈帧，但是没有足够的内存可以分配，就会抛出一个`OutOfMemoryError`。

`栈帧（Frame）`
每次方法调用都会新建一个新的栈帧并把它压栈到栈顶。当方法正常返回或者调用过程中抛出未捕获的异常时，栈帧将出栈。

每个栈帧包含：
1) 局部变量数组
2) 函数返回值
3) 操作数栈
4) 当前方法的运行时常量池引用

**局部变量数组**
`局部变量数组`包含了方法执行过程中的所有变量，包括 this 引用、所有方法参数、其他局部变量。对于类方法（也就是静态方法），方法参数从下标 0 开始，对于对象方法，位置 0 保留为 this 指针。

有下面这些局部变量：
1) `boolean`：布尔值
2) `byte`：字节
3) `char`：字符
4) `short`：短整型
5) `int`：整形
6) `long`：长整型
7) `float`：单精度浮点型
8) `double`：双精度浮点型
9) `reference`：引用
10) `returnAddress`：返回地址

除了**long**和**double**类型(64 bit)以外，所有的变量类型都占用局部变量数组的一个 Slot 空间。long 和 double 需要占用局部变量数组两个连续的 Slot 空间，因为它们是 64 位双精度，其它类型都是 32 位单精度。

**操作数栈**
`操作数栈`在执行字节码指令过程中被用到，这种方式类似于原生 CPU **寄存器**。大部分 JVM 字节码把时间花费在操作数栈的操作上：`入栈`、`出栈`、`复制`、`交换`、`产生消费变量`的操作。因此，局部变量数组和操作数栈之间的交换变量指令操作通过字节码频繁执行。比如，一个简单的变量初始化语句将产生两条跟操作数栈交互的字节码。

**动态链接**
每个栈帧都有一个`运行时常量池的引用`。这个引用指向栈帧`当前运行方法所在类的常量池`。通过这个引用支持`动态链接（dynamic linking）`。

C/C++ 代码一般被编译成对象文件（目标文件），然后多个对象文件被链接到一起产生可执行文件或者动态链接库。在链接阶段，每个对象文件的`符号引用`被替换成了最终执行文件的`相对偏移内存地址`。**在 Java 中，`链接阶段`是`运行时`动态完成的**。

当 Java 类文件编译时，所有变量和方法的引用都被当做`符号引用`存储在这个类的**常量池**中。
**符号引用是一个逻辑引用，实际上并不指向物理内存地址**。

JVM 可以选择符号引用解析的时机：
1) 一种是当**类文件加载并校验通过后**，这种解析方式被称为`饥饿方式`；
2) 另外一种是**符号引用在第一次使用的时候**被解析，这种解析方式称为`惰性方式`。
无论如何 ，JVM 必须要在第一次使用符号引用时完成解析并抛出可能发生的解析错误。

**绑定是将对象域、方法、类的符号引用替换为直接引用的过程**。
绑定只会发生一次，一旦绑定，符号引用会被完全替换。如果一个类的符号引用还没有被解析，那么就会载入这个类。每个直接引用都被存储为相对于存储结构（与运行时变量或方法的位置相关联的）`偏移量`。

**本地方法栈 Native Method Stack**
`本地方法栈`则为虚拟机使用到的 Native 方法提供内存空间，而前面讲的虚拟机栈式为 Java 方法提供内存空间；有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的 HotSpot 虚拟机。

`异常(Exception)`：Java 虚拟机规范规定该区域可抛出`StackOverFlowError`和`OutOfMemoryError`错误。

**Java 堆 Heap**
`Java堆`，是 Java 虚拟机管理的最大的一块内存，也是 GC 的主战场，里面存放的是几乎所有的对象实例和数组数据。
JIT 编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在 Java 堆，而是栈内存，这里不做详细介绍。
- 从`内存回收`角度，Java 堆被分为`新生代`和`老年代`；这样划分的好处是为了更快的回收内存，可以有效的提高 GC 效率；
- 从`内存分配`角度，Java 堆可以划分出**线程私有**的`分配缓冲区(Thread Local Allocation Buffer,TLAB)`；这样划分的好处是为了更快的分配内存；



对象实例的具体结构如下：
![Java 堆中实例对象的存储结构图](/images/java-memory-4.png)

对于填充数据不是一定存在的，仅仅是为了字节对齐：
HotSpot VM 的自动内存管理要求对象起始地址必须是 8 字节的整数倍；对象头本身是 8 的倍数，当对象的实例数据不是 8 的倍数，便需要填充数据来保证 8 字节的对齐，该功能类似于高速缓存行的对齐。

另外，关于在堆上内存分配是**并发进行**的，虚拟机采用 CAS 加失败重试保证原子操作，或者是采用每个线程预先分配 TLAB 内存；

`异常(Exception)`：Java 虚拟机规范规定该区域可抛出`OutOfMemoryError`；

**方法区 Method Area**
`方法区`主要存放的是已被虚拟机加载的`类信息`、`常量`、`静态变量`、编译器编译后的`代码`等数据。GC 在该区域出现的比较少，也称为**永久代**；

`异常(Exception)`：Java 虚拟机规范规定该区域可抛出`OutOfMemoryError`；

**运行时常量池**
`运行时常量池`也是方法区的一部分，用于存放编译器生成的各种`字面量`和`符号引用`。运行时常量池除了编译期产生的 Class 文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是 String 类的 intern() 方法。
- `字面量`：与 Java 语言层面的常量概念相近，包含文本字符串、声明为 final 的常量值等。
- `符号引用`：编译语言层面的概念，包括以下 3 类：
 - 类和接口的全限定名
 - 字段的名称和描述符
 - 方法的名称和描述符


## JVM 类加载机制
JVM 类加载机制分为五个部分：`加载`，`验证`，`准备`，`解析`，`初始化`，如下图所示：
![JVM 类加载机制](/images/java-classload.png)

**加载**
加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口；

注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。

**验证**
这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

**准备**
准备阶段是正式为`类变量`**分配内存并设置类变量的初始值**阶段，即在方法区中分配这些变量所使用的内存空间；

注意这里所说的初始值概念，比如一个类变量定义为：`public static int v = 8080;`
实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 putstatic 指令是程序被编译后，存放于类构造器`<clinit>`方法之中。

但是注意如果声明为：`public static final int v = 8080;`
在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。

**解析**
解析阶段是指虚拟机将常量池中的**符号引用替换为直接引用**的过程。符号引用就是 class 文件中的：
`CONSTANT_Class_info`、`CONSTANT_Field_info`、`CONSTANT_Method_info`等类型的常量。

**初始化**
初始化阶段是类加载最后一个阶段，**初始化阶段是执行类构造器`<clinit>`方法的过程**。

`<clinit>`方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证`<clinit>`方法执行之前，父类的`<clinit>`方法已经执行完毕（如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成`<clinit>`方法）
> 
`<init>`方法：对象实例化方法（构造函数）
`<clinit>`方法：类、接口初始化方法（静态初始化块）

注意以下几种情况不会执行类初始化：
- 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化；
- 定义对象数组，不会触发该类的初始化；
- 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类；
- 通过类名获取 Class 对象，不会触发类的初始化；
- 通过`Class.forName()`加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化；
- 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。



**类加载器 ClassLoader**
JVM 中有多个类加载器，分饰不同的角色。每个类加载器由它的父加载器加载。`Bootstrap`加载器除外，它是所有最顶层的类加载器。
![JVM 类加载器](/images/java-classloader.png)

**Bootstrap 加载器**
Bootstrap 加载器一般由本地代码实现，因为它在 JVM 加载以后的早期阶段就被初始化了；
Bootstrap 加载器负责载入基础的 Java API，比如包含 rt.jar；
Bootstrap 只加载拥有较高信任级别的启动路径下找到的类，因此跳过了很多普通类需要做的校验工作。

**Extension 加载器**
Extension 加载器加载了标准 Java 扩展 API 中的类，比如 security 的扩展函数；

**System 加载器**
System 加载器是应用的默认类加载器，比如从 classpath 中加载应用类；

**自定义加载器**
用户自定义类加载器也可以用来加载应用类；可以通过继承 java.lang.ClassLoader 实现自定义的类加载器；
使用自定义的类加载器有很多特殊的原因：运行时重新加载类或者把加载的类分隔为不同的组，典型的用法比如 WEB 服务器 Tomcat；


## Java 对象的访问方式
一般来说，一个 Java 的引用访问涉及到 3 个内存区域：`JVM栈`，`堆`，`方法区`。

以最简单的本地变量引用：`Object obj = new Object()`为例：
1) `Object obj`表示一个本地引用，存储在`JVM栈`的**本地变量表**中，表示一个 reference 类型数据；
2) `new Object()`作为实例对象数据存储在`堆`中；
3) 堆中还记录了 Object 类的**类型信息**（接口、方法、field、对象类型等）的`地址`，这些地址所执行的数据存储在`方法区`中；

在 Java 虚拟机规范中，对于通过 reference 类型引用访问具体对象的方式并未做规定，目前主流的实现方式主要有两种：
1、通过`句柄`访问：
![通过句柄访问 Object](/images/java-obj-access-1.png)
通过句柄访问的实现方式中，JVM 堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。

2、通过`直接指针`访问：
![通过直接指针访问 Object](/images/java-obj-access-2.png)
通过直接指针访问的方式中，reference 中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在 HotSpot 虚拟机中用的就是这种方式。

因为我们大多数情况下都是使用 HotSpot 虚拟机，所以一般只需要了解`直接指针`的访问方式。

## Java 内存分配机制
这里所说的内存分配，主要指的是在堆上的分配，一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或 String 等），然后在栈上分配，在栈上分配的很少见，我们这里不考虑。

Java 内存分配和内存回收机制概括的说，就是：**分代分配，分代回收**；

对象将根据**存活的时间**被分为：`年轻代（Young Generation）`、`年老代（Old Generation）`、`永久代（Permanent Generation，也就是方法区）`；
> 
`永久代`是 HotSpot 虚拟机特有的概念，它采用永久代的方式来实现`方法区`，其他的虚拟机实现没有这一概念；
而且 HotSpot 也有取消永久代的趋势，在 JDK1.7 中 HotSpot 已经开始了“去永久化”，把原本放在永久代的字符串常量池移出；

**JVM 堆结构图 - 分代**
![JVM 堆结构图 - 分代](/images/java-heap-gen.jpg)

**年轻代 Young Generation**
`年轻代（Young Generation）`：对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代）；

大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的 GC 机制清理掉（IBM 的研究表明，98% 的对象都是很快消亡的），这个 GC 机制被称为`Minor GC`或叫`Young GC`。

年轻代一般分为 3 个区域：
1) `Eden区`：伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，表示内存首次分配的区域，默认大小为 80%；
2) `Survivor 0`：From，存活区 1，默认大小为 10%；
3) `Survivor 1`：To，存活区 2，默认大小为 10%。

- 绝大多数刚创建的对象会被分配在 Eden 区，其中的大多数对象很快就会消亡；Eden 区是连续的内存空间，因此在其上分配内存极快；
- 最初一次，当 Eden 区满的时候，执行 Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区 Survivor0（此时，Survivor1 是空白的，两个 Survivor 总有一个是空白的）；
- 下次 Eden 区满了，再执行一次 Minor GC，将消亡的对象清理掉，将存活的对象复制到 Survivor1 中，然后清空 Eden 区；
- 将 Survivor0 中消亡的对象清理掉，将其中可以晋级的对象晋级到 Old 区，将存活的对象也复制到 Survivor1 区，然后清空 Survivor0 区；
- 当两个存活区切换了几次（HotSpot 虚拟机默认`15次`，用`-XX:MaxTenuringThreshold`控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代；



从上面的过程可以看出，Eden 区是连续的空间，且 Survivor 总有一个为空；

经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换；

因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的**停止-复制（stop-and-copy）**清理法；
这不代表着停止-复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的。

在 Eden 区，HotSpot 虚拟机使用了两种技术来加快内存分配：
1) `bump-the-pointer`
2) `TLAB（Thread-Local Allocation Buffers）`

这两种技术的做法分别是：由于 Eden 区是连续的，因此 bump-the-pointer 技术的核心就是跟踪最后创建的一个对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度；
而对于 TLAB 技术是对于多线程而言的，将 Eden 区分为若干段，每个线程使用独立的一段，避免相互影响；TLAB 结合 bump-the-pointer 技术，将保证每个线程都使用 Eden 区的一段，并快速的分配内存。

**年老代 Old/Tenured Generation**
一个对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC 后存活了下来），则会被复制到年老代；

如果对象比较大（比如长字符串或大数组），Young 空间不足，则大对象会直接分配到老年代上（大对象可能触发提前 GC，应少用，更应避免使用短命的大对象）
用`-XX:PretenureSizeThreshold`来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上；

年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的 GC 次数也比年轻代少；当年老代内存不足时，将执行`Major GC`，也叫`Full GC`；

可以使用`-XX:+UseAdaptiveSizePolicy`开关来控制是否采用动态控制策略，如果动态控制，则动态调整 Java 堆中各个区域的大小以及进入老年代的年龄；

可能存在年老代对象引用新生代对象的情况，如果需要执行 Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的；
解决的方法是，年老代中维护一个 512 byte 的块`card table`，所有老年代对象引用新生代对象的记录都记录在这里；Young GC 时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。


## Java GC 机制
**年轻代**
在新生代中，使用`停止-复制`算法进行清理，将新生代内存分为 2 部分，Eden 区较大，Survivor 比较小，并被划分为两个等量的部分；

每次进行清理时，将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中，然后清理掉 Eden 和刚才的 Survivor；
由于绝大部分的对象都是短命的，甚至存活不到 Survivor 中，所以，Eden 区与 Survivor 的比例较大；HotSpot 默认是 8:1，即分别占新生代的 80%，10%，10%；

如果一次回收中，Survivor + Eden 中存活下来的内存超过了 10%，则需要将一部分对象分配到老年代；
用`-XX:SurvivorRatio`参数来配置 Eden 区域、Survivor 区域的容量比值，默认是 8，代表 Eden:Survivor1:Survivor2 = 8:1:1；

**老年代**
老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用`停止-复制`算法，则相当低效；

一般，老年代用的算法是`标记-整理`算法，即：
**标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续**；

在发生`Minor GC`时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次`Full GC`；

**方法区（永久代）**：
永久代的回收有两种：`常量池中的常量`，`无用的类信息`；
常量的回收很简单，没有引用了就可以被回收；对于无用的类进行回收，必须保证 3 点：
- 类的所有实例都已经被回收
- 加载类的 ClassLoader 已经被回收
- 类对象的 Class 对象没有被引用（即没有通过反射引用该类的地方）



永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收；HotSpot 提供`-Xnoclassgc`进行控制；

**判断对象是否存活**
GC 是通过对象是否存活来决定是否进行回收，判断对象是否存活主要有两种算法：`引用计数算法`、`可达性分析算法`：

1) `引用计数算法`
引用计数的算法原理是给对象添加一个引用计数器，每被引用一次计数器加 1，引用失效时减 1，当计数器 0 后表示对象不在被引用，可以被回收了；
引用计数法简单高效，但是存在对象之间**循环引用**问题，可能导致无法被 GC 回收，需要花很大精力去解决循环引用问题；
> 
Java 没有采用`引用计数算法`，最主要的原因就是很难解决对象之间循环引用的问题；

2) `可达性分析算法`
可达性分析的算法原理是从**对象根引用(`GC Roots`)**开始遍历搜索所有可到达对象，形成一个引用链，遍历的同时标记出可达对象和不可达对象，不可达对象表示没有任何引用存在，可以被 GC 回收；
![可达性分析算法](/images/java-gc-root.jpg)

**当一个对象到 GC Roots 没有任何引用链相连时，则证明这个对象为可回收的对象**；

可以作为`GC Roots`的对象包括下面几种：
1) 栈帧中的`本地变量表`所引用的对象；
2) 方法区中`类静态属性`和`常量`引用的对象；
3) 本地方法栈中`JNI`（Native 方法）引用的对象。

按照对象的`引用可达(Reachable)`强度，由强到弱分为 5 类，如下：
1) `强可达(Strong Reachable)`
在一个线程内，无需引用直接可达，新创建的对象是强可达的；

2) `软可达(Soft Reachable)`
不是强可达的，但是通过一个`软引用(SoftReference)`可达；

3) `弱可达(Weak Reachable)`
既不是强可达也不是软可达，但是通过一个`弱引用(WeakReference)`可达；

4) `虚可达(Phantom Reachable)`
既不是强可达，不是软可达，也不是弱可达，但是通过一个`虚引用(PhantomReference)`可达；

5) `不可达(Unreachable)`
没有任何引用指向对象；

比较好、容易理解的是 Java 垃圾回收器会优先清理可达强度低的对象；另外有两个重要的点：
1) 强可达的一定不会被清理；
2) JVM 保证抛出 OutOfMemoryError 之前，清理所有的软引用对象；

**四种引用类型**
1) `强引用(StrongReference)`
如`Object obj = new Object();`，这里的 obj 引用便是一个强引用，强引用不会被 GC 回收；即使抛出 OutOfMemoryError 错误，使程序异常终止；

2) `软引用(SoftReference)`
如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存；软引用可用来实现内存敏感的高速缓存；

3) `弱引用(WeakReference)`
垃圾回收器一旦发现了弱引用的对象，不管当前内存空间足够与否，都会回收它的内存；不过由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些弱引用的对象；

4) `虚引用(PhantomReference)`
虚引用必须和`引用队列（ReferenceQueue）`联合使用；

总结：
1) `强引用`：不会被 GC 回收，用于对象的一般状态；
2) `软引用`：在内存不足时被 GC 回收，用于对象缓存；
3) `弱引用`：在 GC 执行时被回收，用于对象缓存；

**内存回收算法**
内存回收算法主要有`停止-复制`、`标记-整理`、`标记-清除`；不同算法使用不同的场景，总体来说`停止-复制`算法适合对象存活时间短，存活率低的**新生代**，`标记-清除`和`标记-整理`算法适合对象存活时间长，存活率高的**老年代**。
- `停止-复制(Stop-Copy)`
停止复制算法对于存活率较低的对象回收有着非常高的效率，而且不会形成内存碎片，但是会浪费一定的内存空间，适合对象存活率较低的新生代使用，如果在对象存活率较高的老年代采用这种算法，那将会是一场灾难；
- `标记-整理(Mark-Compact)`
通过可达性分析算法标记所有不可达对象，然后将存活对象都向一个方向移动，然后清理掉边界外的内存；这种算法是将存活对象向着一个方向聚集，然后将剩余区域清空，这种算法适合对象存活率较高的老年代，该算法不会产生内存碎片；
- `标记-清除(Mark-Sweep)`
通过可达性分析算法标记所有不可达对象，然后清理不可达对象；这种算法会形成大量的内存碎片。



一般来说我们所说的 GC 都是发生在`新生代`和`老年代`：
新生代对象存活时间短，存活率低，一般采用`停止-复制`算法；
老年代对象存活时间长，存活率高，一般采用`标记-整理`、`标记-清除`算法，具体采用何种算法和具体采用的垃圾收集器有关。

**GC 收集器**
在 GC 机制中，起重要作用的是垃圾收集器，垃圾收集器是 GC 的具体实现，Java 虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾收集器各不相同。

GC 收集器分为`新生代收集器`和`老年代收集器`，不同的收集器使用不同的收集算法，有着不同的特点；

由于目前的收集器在内存回收时无法消除`stop-the-world`，即在回收内存时不可避免的停止用户线程；
目前的收集器只能使停顿时间越来越短，但是无法彻底消除，主要的收集器中 Parallel Scavenge 和 Parallel Old 是追求吞吐量为目标，其它的收集器都是追求高响应，低停顿。

新生代收集器：`Serial`、`PraNew`、`Parallel Scavenge`；
老年代收集器：`Serial Old`、`Parallel Old`、`CMS`。

1) `Serial`
**新生代收集器**，使用**停止-复制**算法，使用一个线程进行 GC，**串行**，其它工作线程暂停；
`-XX:+UseSerialGC`：启用`Serial + Serial Old`模式（Client 模式的默认值）；

2) `ParNew`
**新生代收集器**，使用**停止-复制**算法，Serial 收集器的多线程版，**并行**，其它工作线程暂停；关注**缩短垃圾收集时间**；
`-XX:+UseParNewGC`：启用`ParNew + Serial Old`模式；
`-XX:ParallelGCThreads`：设置执行内存回收的线程数；

3) `Parallel Scavenge`
**新生代收集器**，使用**停止-复制**算法，**关注 CPU 吞吐量**，即**运行用户代码的时间/总时间**；
比如：JVM 运行 100 分钟，其中运行用户代码 99 分钟，垃圾收集 1 分钟，则吞吐量是 99%；
`-XX:+UseParallelGC`：启用`Parallel Scavenge + Serial Old`模式（Server 模式的默认值）；
`-XX:GCTimeRatio`：设置用户执行时间占总时间的比例，默认 99，即 1% 的时间用来进行垃圾回收；
`-XX:MaxGCPauseMillis`：设置 GC 的最大停顿时间(ms毫秒)（只对 Parallel Scavenge 有效）；

4) `Serial Old`
**老年代收集器**，单线程收集器，**串行**，使用**标记-整理**算法，其它工作线程暂停；
在 JDK1.5 之前，Serial Old 收集器与 Parallel Scavenge 搭配使用；

5) `Parallel Old`
**老年代收集器**，多线程，**并行**，多线程机制与 Parallel Scavenge 差不多，使用**标记-整理**算法，在多核计算中很有用；
Parallel Old 出现后（JDK 1.6），与 Parallel Scavenge 配合有很好的效果，充分体现 Parallel Scavenge 收集器吞吐量优先的效果；
`-XX:+UseParallelOldGC`：启用`Parallel Scavenge + Parallel Old`模式；

6) `CMS（Concurrent Mark Sweep）`
**老年代收集器**，致力于获取**最短回收停顿时间**，使用**标记-清除**算法，多线程，优点是**并发收集**（用户线程可以和 GC 线程同时工作），停顿小；
`-XX:+UseConcMarkSweepGC`：启用`ParNew + CMS + Serial Old`进行内存回收；
优先使用`ParNew + CMS`，当用户线程内存不足时，采用备用方案`ParNew + Serial Old`。

7) `G1`
G1 收集器是一款**面向服务端应用的垃圾收集器**；HotSpot 团队赋予它的使命是在未来替换掉 JDK1.5 中发布的 CMS 收集器；

与其他 GC 收集器相比，G1 具备如下特点：
- `并行与并发`：G1 能更充分的利用 CPU，多核环境下的硬件优势来缩短 Stop-The-World 的停顿时间；
- `分代收集`：和其他收集器一样，分代的概念在 G1 中依然存在，不过 G1 不需要其他的垃圾回收器的配合就可以独自管理整个 GC 堆；
- `空间整合`：G1 收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次 GC；
- `可预测的非停顿`：这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒；



使用 G1 收集器时，Java 堆的内存布局和其他收集器有很大的差别：
G1 将整个 Java 堆分为多个大小相等的独立区域；
虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合；

> 
虽然 G1 看起来有很多优点，实际上 CMS 还是主流。


## JVM 启动参数
**javac 常用参数**
`-classpath <路径>`：指定 CLASSPATH 搜索路径；
`-cp <路径>`：指定 CLASSPATH 搜索路径；

`-Xlint`：输出所有可用的警告信息；
`-Xlint:all`：输出所有可用的警告信息；
`-Xlint:none`：不输出任何警告信息；

`-g`：生成调试信息；
`-g:none`：不生成调试信息；

`-Werror`：出现警告时终止编译；
`-nowarn`：不生成任何警告；
`-verbose`：输出编译过程的详细信息；

`-deprecation`：输出使用已过时 API 的源位置；

`-encoding <编码>`：指定源文件使用的字符编码；

`-source <jdk版本>`：指定源文件的 jdk 版本；
`-target <jdk版本>`：指定类文件的 jdk 版本；

`-version`：版本信息；
`-help`：输出标准选项的提要；


**java 常用参数**
`-classpath <目录>`：指定 CLASSPATH 搜索路径；
`-cp <目录>`：指定 CLASSPATH 搜索路径；

`-server`：使用 Server VM 虚拟机（64bit 默认）；
`-client`：使用 Client VM 虚拟机（64bit 无效）；

`-d32`：使用 32 位数据模型 (如果可用)；
`-d64`：使用 64 位数据模型 (如果可用)；

`-verbose:[class|gc|jni]`：启用详细输出；

`-version`：输出版本信息并退出；
`-showversion`：输出版本信息并继续；

`-?/-help`：输出帮助消息；

**java 启动参数**
**堆栈大小相关**
`-Xss2m`：每个线程的 VM Stack 栈大小；jdk1.5 之前默认 256k，jdk1.5 之后默认 1m；
`-Xms1024m`：初始堆大小；通常和 -Xmx 大小一样；
`-Xmx1024m`：最大堆大小；
`-XX:MaxDirectMemorySize=128M`：直接内存最大值，默认与 Java 堆的最大值相同；

**年轻代/年老代/永久代相关**
`-Xmn384m`：新生代大小，推荐配置为整个堆的 3/8；
`-XX:SurvivorRatio`：年轻代中 Eden 和 Survivor 区域的大小比例，默认为 8，即：`Eden:Survivor0:Survivor1 = 8:1:1`；

`-XX:Permsize=384m`：设置永久代初始值；
`-XX:MaxPermsize=384m`：设置永久代的最大值；
> 
Java8 没有永久代说法，它们被称为**元空间**，`-XX:MetaspaceSize=N`；

`-XX:+UseAdaptiveSizePolicy`：启用动态控制，动态调整 Java 堆中各个区域的大小以及进入老年代的年龄；
`-XX:PretenureSizeThreshold=2m`：直接进入年老代的大对象的大小，默认单位为字节 byte；
`-XX:MaxTenuringThreshold=10`：设置新生代中对象进入老年代的年龄，最大为 15 岁；
对于 parallel 并行垃圾收集器来说，默认值是 15；对于 CMS 垃圾收集器来说，默认值是 6。

**GC 收集器相关**
`-XX:+UseSerialGC`：使用 Serial + Serial Old 组合（不建议）；

`-XX:+UseParNewGC`：使用 ParNew + Serial Old 组合；
`-XX:ParallelGCThreads`：设置执行内存回收的线程数；

`-XX:+UseParallelGC`：使用 Parallel Scavenge + Serial Old 组合（Server 模式的默认值）；
`-XX:+UseParallelOldGC`：使用 Parallel Scavenge + Parallel Old 组合；
`-XX:GCTimeRatio`：设置用户执行时间占总时间的比例，默认 99，即 1% 的时间用来进行垃圾回收；
`-XX:MaxGCPauseMillis`：设置 GC 的最大停顿时间(ms 毫秒为单位)（只对 Parallel Scavenge 有效）；

`-XX:+UseConcMarkSweepGC`：使用 ParNew + CMS + Serial Old 进行内存回收；
优先使用 ParNew + CMS，当用户线程内存不足时，采用备用方案 ParNew + Serial Old；
`-XX:ParallelGCThreads=4`：设置垃圾收集线程数，默认是`(CPU个数 + 3)/4`；
`-XX:CMSInitiatingOccupancyFraction=80`：老年代垃圾占比达此阈值时开始 CMS 收集；默认为 92；设置过高容易导致并发收集失败，会出现 SerialOld 收集的情况；
`-XX:+UseCMSCompactAtFullCollection`：在 Full GC 时，对年老代进行压缩，可能会影响性能；但是可以消除内存碎片；
`-XX:CMSFullGCsBeforeCompaction=1`：进行 Full GC 多少次后进行内存压缩；
`-XX:+CMSParallelRemarkEnabled`：为了减少第二次暂停的时间，开启并行 remark，降低标记停顿；

`-XX:+UseG1GC`：使用 G1 垃圾收集器，谨慎使用，需要经过线上测试，还没有被设置为默认垃圾收集器；

**打印日志相关**
`-verbose:gc`：打印 GC 日志；
`-XX:+PrintGC`：打印 GC 基本日志；
`-XX:+PrintGCDetails`：打印 GC 详细日志；
`-XX:+PrintGCTimeStamps`：打印 GC 相对时间戳；
`-XX:+PrintGCApplicationStoppedTime`：打印 GC 期间程序暂停的时间；
`-XX:+PrintGCApplicationConcurrentTime`：打印每次垃圾回收前，程序未中断的执行时间；
`-XX:+PrintTenuringDistribution`：查看每次 Minor GC 后新的存活周期的阈值；
`-XX:+PrintTLAB`：查看 TLAB 空间的使用情况；
`-Xloggc:filename`：把相关日志信息记录到文件以便分析；

**OOM 转储相关**
`-XX:+HeapDumpOnOutOfMemoryError`：发生 OOM 内存溢出错误时自动生成堆转储文件；
`-XX:HeapDumpPath=filename`：指定堆转储文件的路径及文件名；
